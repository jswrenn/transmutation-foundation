<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Foundational Proposal</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Overview</a></li><li class="chapter-item expanded "><a href="neglect.html"><strong aria-hidden="true">1.</strong> Spotlight: Neglect</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="neglect-why.html"><strong aria-hidden="true">1.1.</strong> Why do we need Neglect?</a></li><li class="chapter-item expanded "><a href="neglect-encoding.html"><strong aria-hidden="true">1.2.</strong> Why is Neglect a const parameter?</a></li><li class="chapter-item expanded "><a href="neglect-combining.html"><strong aria-hidden="true">1.3.</strong> How should Neglects be created, combined?</a></li></ol></li><li class="chapter-item expanded "><a href="scope.html"><strong aria-hidden="true">2.</strong> Spotlight: Scope</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scope-safety.html"><strong aria-hidden="true">2.1.</strong> Why is safety dependent on context?</a></li><li class="chapter-item expanded "><a href="scope-mechanism.html"><strong aria-hidden="true">2.2.</strong> How does Scope ensure safety?</a></li><li class="chapter-item expanded "><a href="scope-inference.html"><strong aria-hidden="true">2.3.</strong> Can't Scope be elided?</a></li></ol></li><li class="chapter-item expanded "><a href="use-case-auditing.html"><strong aria-hidden="true">3.</strong> Use-Case: Auditing</a></li><li class="chapter-item expanded "><a href="use-case-abstraction.html"><strong aria-hidden="true">4.</strong> Use-Case: Abstraction</a></li><li class="chapter-item expanded "><a href="unresolved.html"><strong aria-hidden="true">5.</strong> Unresolved Questions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="unresolved-trait-name.html"><strong aria-hidden="true">5.1.</strong> Trait Name</a></li><li class="chapter-item expanded "><a href="unresolved-trait-methods.html"><strong aria-hidden="true">5.2.</strong> Trait Methods</a></li><li class="chapter-item expanded "><a href="unresolved-trait-orientation.html"><strong aria-hidden="true">5.3.</strong> Trait Orientation</a></li><li class="chapter-item expanded "><a href="unresolved-src-visibility.html"><strong aria-hidden="true">5.4.</strong> Visibility of Src</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Foundational Proposal</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#overview" id="overview">Overview</a></h1>
<p>We propose that this <em>compiler-intrinsic</em> trait (end-users <em>cannot</em> implement it) be added to <code>core::mem</code>:</p>
<pre><code class="language-rust ignore">pub unsafe trait BikeshedIntrinsicFrom&lt;Src, Scope, const NEGLECT: Neglect&gt;
where
    Src: ?Sized
{}
</code></pre>
<p>This trait is capable of telling you whether a particular bit-reinterpretation cast from <code>Src</code> to <code>Self</code> is well-defined and safe (notwithstanding whatever static checks you decide to <code>Neglect</code>).</p>
<p>This trait is useful:</p>
<ol>
<li><a href="./use-case-auditing.html">for auditing the safety of existing code</a></li>
<li><a href="./use-case-abstraction.html">as a foundation for high-level abstractions</a></li>
</ol>
<h2><a class="header" href="#when-is-a-transmutation-well-defined-and-safe" id="when-is-a-transmutation-well-defined-and-safe">When is a transmutation well-defined and safe?</a></h2>
<p>A transmutation is <strong>well-defined</strong> if <em>any</em> possible values of type <code>Src</code> are a valid instance of <code>Dst</code>. The compiler determines this by inspecting the layouts of <code>Src</code> and <code>Dst</code>.</p>
<p>In order to be <strong>safe</strong>, a well-defined transmutation must also not allow you to:</p>
<ol>
<li>construct instances of a hidden <code>Dst</code> type</li>
<li>mutate hidden fields of the <code>Src</code> type</li>
<li>construct hidden fields of the <code>Dst</code> type</li>
</ol>
<p>Whether these conditions are satisfied depends on the scope the transmutation occurs in. The existing mechanism of <a href="https://rust-lang.github.io/rfcs/2145-type-privacy.html">type privacy</a> will ensure that first condition is satisfied. To enforce the second and third conditions, we introduce the <code>Scope</code> type parameter (see below). </p>
<h2><a class="header" href="#what-is-neglect" id="what-is-neglect">What is <code>Neglect</code>?</a></h2>
<p>The <code>Neglect</code> parameter encodes the set of static checks that the compiler should ignore when determining transmutability. These checks include:</p>
<ul>
<li>alignment</li>
<li>lifetimes</li>
<li>validity</li>
<li>visibility</li>
</ul>
<p>Neglecting <em>any</em> static checks disqualifies a transmutation from being safe. The <code>Neglect</code> type is represented like this:</p>
<pre><code class="language-rust ignore">#[derive(PartialEq, Eq)]
#[non_exhaustive]
pub struct Neglect {
    pub alignment   : bool,
    pub lifetimes   : bool,
    pub validity    : bool,
    pub visibility  : bool,
}

impl Neglect {
    pub const NOTHING: Self = Self {
        alignment   : false,
        lifetimes   : false,
        validity    : false,
        visibility  : false,
    };

    pub const ALIGNMENT:  Self = Self {alignment: true, ..Self::NOTHING};
    pub const LIFETIMES:  Self = Self {lifetimes: true, ..Self::NOTHING};
    pub const VALIDITY:   Self = Self {validity:  true, ..Self::NOTHING};
    pub const VISIBILITY: Self = Self {validity:  true, ..Self::NOTHING};
}

impl const core::ops::Add for Neglect {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        Self {
            alignment   : self.alignment  || other.alignment,
            lifetimes   : self.lifetimes  || other.lifetimes,
            validity    : self.validity   || other.validity,
            visibility  : self.visibility || other.visibility,
        }
    }
}
</code></pre>
<p><strong>For more information, see <a href="neglect.html">here</a>.</strong></p>
<h2><a class="header" href="#what-is-scope" id="what-is-scope">What is <code>Scope</code>?</a></h2>
<p>The <code>Scope</code> parameter of <code>BikeshedIntrinsicFrom</code> is used to ensure that the second and third safety conditions are satisfied.</p>
<p>When visibility is enforced, <code>Scope</code> must be instantiated with any private (i.e., <code>pub(self)</code> type. The compiler pretends that it is at the defining scope of that type, and checks that the necessary fields of <code>Src</code> and <code>Dst</code> are visible.</p>
<p>When visibility is neglected, the <code>Scope</code> parameter is ignored.</p>
<p><strong>For more information, see <a href="scope.html">here</a>.</strong></p>
<h1><a class="header" href="#spotlight-on-neglect" id="spotlight-on-neglect">Spotlight on <code>Neglect</code></a></h1>
<ul>
<li><a href="./neglect-why.html">Why do we need <code>Neglect</code>?</a></li>
<li><a href="./neglect-encoding.html">Why is <code>Neglect</code> a <code>const</code> parameter?</a></li>
<li><a href="./neglect-combining.html">How should <code>Neglect</code> values be created, combined?</a></li>
</ul>
<h1><a class="header" href="#why-do-we-need-neglect" id="why-do-we-need-neglect">Why do we need Neglect?</a></h1>
<p>The ability to neglect particular static checks makes <code>BikeshedIntrinsicFrom</code> useful in scenarios where aspects of well-definedness and safety are ensured through other means.</p>
<h2><a class="header" href="#example-neglecting-alignment" id="example-neglecting-alignment">Example: Neglecting Alignment</a></h2>
<p>For the instantiation of a <code>&amp;'dst Dst</code> from any <code>&amp;'src Src</code> to be safe, the minimum required alignment of all <code>Src</code> must be stricter than the minimum required alignment of <code>Dst</code>, among other factors (e.g., <code>'src</code> must outlive <code>'dst</code>). By default, <code>BikeshedIntrinsicFrom</code> will enforce these requirements statically.</p>
<p>However, for the instantiation of a <code>&amp;'dst Dst</code> from a <em>particular</em> <code>&amp;'src Src</code> to be safe, we can just check that the alignment of that <em>particular</em> <code>&amp;'src Src</code> is sufficient using <code>mem::align_of</code> (e.g., see bytemuck's <a href="https://docs.rs/bytemuck/1.4.1/bytemuck/fn.try_cast_ref.html">try_cast_ref</a> method).</p>
<p>Using a <code>NEGLECT</code> parameter of <code>Neglect::ALIGNMENT</code> makes <code>BikeshedIntrinsicFrom</code> useful in this scenario. With that <code>NEGLECT</code> parameter, <code>BikeshedIntrinsicFrom</code> neglects only its static alignment check, which we then assume responsibility to enforce ourselves; e.g.:</p>
<pre><code class="language-rust ignore">/// Try to convert a `&amp;'src Src` into `&amp;'dst Dst`.
///
/// This produces `None` if the referent isn't appropriately
/// aligned, as required by the destination type.
fn try_cast_ref&lt;'src, 'dst, Src, Dst, Scope&gt;(src: &amp;'src Src) -&gt; Option&lt;&amp;'dst Dst&gt;
where
    &amp;'t T: BikeshedIntrinsicFrom&lt;&amp;'dst Dst, Scope, Neglect::ALIGNMENT&gt;,
{
    // check alignment dynamically
    if (src as *const Src as usize) % align_of::&lt;Dst&gt;() != 0 {
        None
    } else {
        // SAFETY: we've dynamically enforced the alignment requirement.
        // `BikeshedIntrinsicFrom` statically enforces all other safety reqs.
        unsafe { &amp;*(src as *const Src as *const Dst) }
    }
}
</code></pre>
<h1><a class="header" href="#why-is-neglect-a-const-parameter" id="why-is-neglect-a-const-parameter">Why is Neglect a const parameter?</a></h1>
<p>We've considered <a href="https://hackmd.io/@jswrenn/S192QCR9D">a few different ways</a> in which <code>Neglect</code> might be represented. An ideal representation has three properties:</p>
<ol>
<li>is defaultable with &quot;neglect nothing&quot;, so doing the totally safe thing is truly the easiest thing</li>
<li>every subset of neglected options has exactly <em>one</em> encoding (i.e., neglecting validity and alignment is the same as neglecting alignment and validity)</li>
<li>is generically adjustable (i.e., I can add or remove a neglect from an existing set of options)</li>
</ol>
<p>The type parameter approaches we've considered tick both the first box, and <em>either</em> the second xor third. The sorts of type system extensions that would permit ticking all three of these boxes with a type parameter are far off.</p>
<p>In contrast:</p>
<ol>
<li>A const generic <code>Neglect</code> parameter is <em>not</em> (yet) defaultable, but this doesn't seem like a permanent limitation of const generics.</li>
<li>The const generic <code>Neglect</code> admits exactly one encoding of each subset. The value produced by <code>Neglect {alignment: true, validity: true}</code> is identical to the value produced by <code>Neglect {validity: true, alignment: true}</code>.</li>
<li>The const generic <code>Neglect</code> is generically extendable. Given an existing, arbitrary <code>NEGLECT</code>, we additionally can disable the alignment check with <code>{Neglect::ALIGNMENT + NEGLECT}</code>.</li>
</ol>
<h1><a class="header" href="#how-should-neglect-values-be-created-combined" id="how-should-neglect-values-be-created-combined">How should <code>Neglect</code> values be created, combined?</a></h1>
<p>To initialize and combine <code>Neglect</code> values, this proposal defines a set of associated constants and an <code>Add</code> impl:</p>
<pre><code class="language-rust ignore">impl Neglect {
    pub const NOTHING: Self = Self {
        alignment   : false,
        lifetimes   : false,
        validity    : false,
        visibility  : false,
    };

    pub const ALIGNMENT:  Self = Self {alignment: true, ..Self::NOTHING};
    pub const LIFETIMES:  Self = Self {lifetimes: true, ..Self::NOTHING};
    pub const VALIDITY:   Self = Self {validity:  true, ..Self::NOTHING};
    pub const VISIBILITY: Self = Self {validity:  true, ..Self::NOTHING};
}

impl const core::ops::Add for Neglect {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        Self {
            alignment   : self.alignment  || other.alignment,
            lifetimes   : self.lifetimes  || other.lifetimes,
            validity    : self.validity   || other.validity,
            visibility  : self.visibility || other.visibility,
        }
    }
}
</code></pre>
<p>Consequently, <code>Neglect</code> values can be ergonomically created (e.g., <code>Neglect::ALIGNMENT</code>) and combined (e.g., <code>Neglect::ALIGNMENT + Neglect::VALIDITY + NEGLECT</code>).</p>
<p>Let's contrast this approach with two other possibilities:</p>
<h2><a class="header" href="#alternative-minimalism" id="alternative-minimalism">Alternative: Minimalism</a></h2>
<p>Alternatively, we might only provide:</p>
<pre><code class="language-rust ignore">impl Neglect {
    pub const NOTHING: Self = Self {
        alignment   : false,
        lifetimes   : false,
        validity    : false,
        visibility  : false,
    };
}
</code></pre>
<p>This is the minimum impl we must provide for <code>Neglect</code> to be useful. With it, <code>Neglect</code> values can be created:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const NEGLECT_ALIGNMENT: Neglect = {
  let mut neglect = Neglect::NOTHING;
  neglect.alignment = true;
  neglect
};
<span class="boring">}
</span></code></pre></pre>
<p>and combined:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const ALSO_NEGLECT_ALIGNMENT_VALIDITY: Neglect = {
  let mut neglect = NEGLECT;
  neglect.alignment = true;
  neglect.validity = true;
  neglect
};
<span class="boring">}
</span></code></pre></pre>
<p>This approach achieves minimalism at the cost of ergonomics.</p>
<h2><a class="header" href="#alternative-builder-methods" id="alternative-builder-methods">Alternative: Builder Methods</a></h2>
<p>Alternatively, we could define chainable builder methods:</p>
<pre><code class="language-rust ignore">impl Neglect {
    pub const NOTHING: Self = Neglect {
        alignment   : false,
        lifetimes   : false,
        validity    : false,
        visibility  : false,
    };

    pub const fn alignment(self)  -&gt; Self { Neglect { alignment:  true, ..self } }
    pub const fn lifetimes(self)  -&gt; Self { Neglect { lifetimes:  true, ..self } }
    pub const fn validity(self)   -&gt; Self { Neglect { validity:   true, ..self } }
    pub const fn visibility(self) -&gt; Self { Neglect { visibility: true, ..self } }
}
</code></pre>
<p>With this, <code>Neglect</code> values can be created:</p>
<pre><code class="language-rust ignore">Neglect::NOTHING.alignment()
</code></pre>
<p>...and combined:</p>
<pre><code class="language-rust ignore">NEGLECT.alignment().validity()
</code></pre>
<p>This approach is almost as succinct as the approach selected by this proposal (i.e., the <code>Add</code> impl), but meaning of the resulting expressions are not quite as self-evident.</p>
<h1><a class="header" href="#spotlight-scope" id="spotlight-scope">Spotlight: Scope</a></h1>
<ul>
<li><a href="./scope-safety.html">Why is safety dependent on context?</a></li>
<li><a href="./scope-mechanism.html">How does <code>Scope</code> ensure safety?</a></li>
<li><a href="./scope-inference.html">Why can't <code>Scope</code> be elided?</a></li>
</ul>
<h1><a class="header" href="#why-is-safety-dependent-on-context" id="why-is-safety-dependent-on-context">Why is safety dependent on context?</a></h1>
<p>In order to be safe, a well-defined transmutation must also not allow you to:</p>
<ol>
<li>construct instances of a hidden <code>Dst</code> type</li>
<li>mutate hidden fields of the <code>Src</code> type</li>
<li>construct hidden fields of the <code>Dst</code> type</li>
</ol>
<p>Whether these conditions are satisfied depends on the scope the transmutation occurs in, because scope determines the visibility of fields. Consider:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod a {
    use super::*;

    #[repr(C)]
    pub struct NonZeroU32(u32);

    impl NonZeroU32 {
        fn new(v: u32) -&gt; Self {
            unsafe { core::mem::transmute(v) } // sound.
        }
    }
}

mod b {
    use super::*;

    fn new(v: u32) -&gt; a::NonZeroU32 {
        unsafe { core::mem::transmute(v) } // ☢️ UNSOUND!
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The transmutation in <code>b</code> is unsound because it constructs a hidden field of <code>NonZeroU32</code>.</p>
<h1><a class="header" href="#how-does-scope-ensure-safety" id="how-does-scope-ensure-safety">How does <code>Scope</code> ensure safety?</a></h1>
<p>It's generally unsound to construct instances of types for which you do not have a constructor.</p>
<p>If <code>BikeshedIntrinsicFrom</code> <em>lacked</em> a <code>Scope</code> parameter; e.g.,:</p>
<pre><code class="language-rust ignore">// we'll also omit `NEGLECT` for brevity
pub unsafe trait BikeshedIntrinsicFrom&lt;Src&gt;
where
    Src: ?Sized
{}
</code></pre>
<p>...we could not use it to check the soundness of the transmutations in this example:</p>
<pre><code class="language-rust ignore">mod a {
    use super::*;

    mod npc {
        #[repr(C)]
        pub struct NoPublicConstructor(u32);
        
        impl NoPublicConstructor {
            pub(super) fn new(v: u32) -&gt; Self {
                assert!(v % 2 == 0);
                assert_impl!(NoPublicConstructor: BikeshedIntrinsicFrom&lt;u32&gt;);
                unsafe { core::mem::transmute(v) } // okay.
            }

            pub fn method(self) {
                if self.0 % 2 == 1 {
                    // totally unreachable, thanks to assert in `Self::new`
                    unsafe { *std::ptr::null() }
                }
            }
        }
    }

    use npc::NoPublicConstructor;
}

mod b {
    use super::*;

    fn new(v: u32) -&gt; a::NoPublicConstructor {
        assert_not_impl!(NoPublicConstructor: BikeshedIntrinsicFrom&lt;u32&gt;);
        unsafe { core::mem::transmute(v) } // ☢️ BAD!
    }
}
</code></pre>
<p>In module <code>a</code>, <code>NoPublicConstructor</code> must implement <code>BikeshedIntrinsicFrom&lt;u32&gt;</code>. In module <code>b</code>, it must not. This inconsistency is incompatible with Rust's trait system.</p>
<h2><a class="header" href="#solution" id="solution">Solution</a></h2>
<p>We resolve this inconsistency by introducing a type parameter, <code>Scope</code>, that allows Rust to distinguish between these two contexts:</p>
<pre><code class="language-rust ignore">// we omit `NEGLECT` for brevity
pub unsafe trait BikeshedIntrinsicFrom&lt;Src, Scope&gt;
where
    Src: ?Sized
{}
</code></pre>
<p><code>Scope</code> must be instantiated with any private (i.e., <code>pub(self)</code> type. To determine whether a transmutation is safe, the compiler pretends that it is at the defining scope of that type, and checks that the necessary fields of <code>Src</code> and <code>Dst</code> are visible.</p>
<p>For example:</p>
<pre><code class="language-rust ignore">mod a {
    use super::*;

    mod npc {
        #[repr(C)]
        pub struct NoPublicConstructor(u32);
        
        impl NoPublicConstructor {
            pub(super) fn new(v: u32) -&gt; Self {
                assert!(v % 2 == 0);
                struct A; // a private type that represents this context
                assert_impl!(NoPublicConstructor: BikeshedIntrinsicFrom&lt;u32, A&gt;);
                unsafe { core::mem::transmute(v) } // okay.
            }

            pub fn method(self) {
                if self.0 % 2 == 1 {
                    // totally unreachable, thanks to assert in `Self::new`
                    unsafe { *std::ptr::null() }
                }
            }
        }
    }

    use npc::NoPublicConstructor;
}

mod b {
    use super::*;

    fn new(v: u32) -&gt; a::NoPublicConstructor {
        struct B; // a private type that represents this context
        assert_not_impl!(NoPublicConstructor: BikeshedIntrinsicFrom&lt;u32, B&gt;);
        unsafe { core::mem::transmute(v) } // ☢️ BAD!
    }
}
</code></pre>
<p>In module <code>a</code>, <code>NoPublicConstructor</code> implements <code>BikeshedIntrinsicFrom&lt;u32, A&gt;</code>. In module <code>b</code>, <code>NoPublicConstructor</code> does <em>not</em> implement <code>BikeshedIntrinsicFrom&lt;u32, B&gt;</code>. There is no inconsistency.</p>
<h1><a class="header" href="#cant-scope-be-elided" id="cant-scope-be-elided">Can't Scope be elided?</a></h1>
<p><strong>Not generally.</strong></p>
<p>Consider a hypothetical <code>FromZeros</code> trait that indicates whether <code>Self</code> is safely initializable from a sufficiently large buffer of zero-initialized bytes:</p>
<pre><code class="language-rust ignore">pub mod zerocopy {
    pub unsafe trait FromZeros&lt;const NEGLECT: Neglect&gt; {
        /// Safely initialize `Self` from zeroed bytes.
        fn zeroed() -&gt; Self;
    }

    #[repr(u8)]
    enum Zero {
        Zero = 0u8
    }

    unsafe impl&lt;Dst, const NEGLECT: Neglect&gt; FromZeros&lt;NEGLECT&gt; for Dst
    where
        Dst: BikeshedIntrinsicFrom&lt;[Zero; mem::MAX_OBJ_SIZE], ???, NEGLECT&gt;,
    {
        fn zeroed() -&gt; Self {
            unsafe { mem::transmute([Zero; size_of::&lt;Self&gt;]) }
        }
    }
}
</code></pre>
<p>The above definition leaves ambiguous (<code>???</code>) the scope in which the constructability of <code>Dst</code> is checked: is it from the perspective of where this trait is defined, or where this trait is <em>used</em>? In this example, you probably do <em>not</em> intend for this trait to <em>only</em> be usable with <code>Dst</code> types that are defined in the same scope as the <code>FromZeros</code> trait!</p>
<p>An explicit <code>Scope</code> parameter on <code>FromZeros</code> makes this unambiguous; the transmutability of <code>Dst</code> should be assessed from where the trait is used, <em>not</em> where it is defined:</p>
<pre><code class="language-rust ignore">pub unsafe trait FromZeros&lt;Scope, const NEGLECT: Neglect&gt; {
    /// Safely initialize `Self` from zeroed bytes.
    fn zeroed() -&gt; Self;
}

unsafe impl&lt;Dst, Scope, const NEGLECT: Neglect&gt; FromZeros&lt;Scope, NEGLECT&gt; for Dst
where
    Dst: BikeshedIntrinsicFrom&lt;[Zero; usize::MAX], Scope, NEGLECT&gt;
{
    fn zeroed() -&gt; Self {
        unsafe { mem::transmute([Zero; size_of::&lt;Self&gt;]) }
    }
}
</code></pre>
<h1><a class="header" href="#use-case-auditing-existing-code" id="use-case-auditing-existing-code">Use-Case: Auditing Existing Code</a></h1>
<p><code>BikeshedIntrinsicFrom</code> can be used to audit the soundness of existing transmutations in code-bases. This macro demonstrates a drop-in replacement to <code>mem::transmute</code> that produces a compile error if the transmutation is unsound:</p>
<pre><code class="language-rust ignored">macro_rules! transmute {
    ($src:expr) =&gt; {transmute!($src, Neglect {})};
    ($src:expr, Neglect { $( $neglect:ident ),* } ) =&gt; {{
        #[inline(always)]
        unsafe fn transmute&lt;Src, Dst, Scope, const NEGLECT: Neglect&gt;(src: Src) -&gt; Dst
        where
            Dst: BikeshedIntrinsicFrom&lt;Src, Scope, NEGLECT&gt;
        {
            #[repr(C)]
            union Transmute&lt;Src, Dst&gt; {
                src: ManuallyDrop&lt;Src&gt;,
                dst: ManuallyDrop&lt;Dst&gt;,
            }

            ManuallyDrop::into_inner(Transmute { src: ManuallyDrop::new(src) }.dst)
        }

        struct Scope;

        const NEGLECT: Neglect = {
            let mut neglect = Neglect::NOTHING;
            $(neglect . $neglect = true;)*
            neglect
        };

        transmute::&lt;_, _, Scope, NEGLECT&gt;($src)
    }};
}
</code></pre>
<p>For example, consider this use of <code>mem::transmute</code>:</p>
<pre><code class="language-rust ignore">unsafe fn foo(v: u8) -&gt; bool {
    mem::transmute(v)
}
</code></pre>
<p>Swapping <code>mem::transmute</code> out for our macro (rightfully) produces a compile error:</p>
<pre><code class="language-rust ignore">unsafe fn foo(v: u8) -&gt; bool {
    unsafe { transmute!(v) } // Compile Error!
}
</code></pre>
<p>...that we may resolve by explicitly neglecting validity:</p>
<pre><code class="language-rust ignore">fn foo(v: u8) -&gt; bool {
    assert!(v &lt; 2);
    unsafe { transmute!(v, Neglect { validity }) }
}
</code></pre>
<h1><a class="header" href="#use-case-abstraction" id="use-case-abstraction">Use-Case: Abstraction</a></h1>
<p>Like <code>size_of</code> and <code>align_of</code>, <code>BikeshedIntrinsicFrom</code> is not SemVer-conscious. However, we can use it as the foundation for a variety of SemVer-conscious APIs.</p>
<h2><a class="header" href="#example-muckable" id="example-muckable">Example: Muckable</a></h2>
<p>In this example, end-users implement the unsafe marker trait <code>Muckable</code> to denote can be cast (via <code>MuckFrom</code>) from or into any other compatible, <code>Muckable</code> type:</p>
<pre><code class="language-rust ignore">/// Implemented by user to denote that the type and its fields (recursively):
///   - promise complete layout stability
///   - have no library invariants on their values
pub unsafe trait Muckable {}

/// Implemented if `Self` can be mucked from the bits of `Src`.
pub unsafe trait MuckFrom&lt;Src&gt;
{
    fn muck_from(src: Src) -&gt; Self
    where
        Self: Sized;
}

unsafe impl&lt;Src, Dst&gt; MuckFrom&lt;Src&gt; for Dst
where
    Src: Muckable,
    Dst: Muckable,
    Dst: BikeshedIntrinsicFrom&lt;Src, !, {Neglect::VISIBILITY}&gt;
{
    fn muck_from(src: Src) -&gt; Self
    where
        Self: Sized,
    {
        #[repr(C)]
        union Transmute&lt;Src, Dst&gt; {
            src: ManuallyDrop&lt;Src&gt;,
            dst: ManuallyDrop&lt;Dst&gt;,
        }

        unsafe { ManuallyDrop::into_inner(Transmute { src: ManuallyDrop::new(src) }.dst) }
    }
}
</code></pre>
<h1><a class="header" href="#unresolved-questions" id="unresolved-questions">Unresolved Questions</a></h1>
<ul>
<li><a href="./unresolved-trait-name.html">Trait Name</a></li>
<li><a href="./unresolved-trait-methods.html">Trait Methods</a></li>
<li><a href="./unresolved-trait-orientation.html">Trait Orientation</a></li>
<li><a href="./unresolved-src-visibility.html">Visibility of Src</a></li>
</ul>
<h1><a class="header" href="#what-should-the-name-of-membikeshedintrinsicfrom-be" id="what-should-the-name-of-membikeshedintrinsicfrom-be">What should the name of <code>mem::BikeshedIntrinsicFrom</code> be?</a></h1>
<h2><a class="header" href="#choice-verb-vs-adjective" id="choice-verb-vs-adjective">Choice: Verb vs. Adjective</a></h2>
<p>E.g., <code>TransmuteFrom</code> or <code>TransmutableFrom</code>?</p>
<p>Most trait names can be read as verbs (e.g., <code>convert::From</code>, <code>Send</code>, <code>Sync</code>), but <code>Sized</code> is a notable exception. Which convention should our trait follow?</p>
<h2><a class="header" href="#choice-root-word" id="choice-root-word">Choice: Root Word</a></h2>
<p>E.g., <code>TransmuteFrom</code> or <code>BitsFrom</code>?</p>
<p>We have many options for root word:</p>
<ul>
<li><code>Transmute</code></li>
<li><code>Reinterpret</code></li>
<li><code>Cast</code></li>
<li><code>Bits</code></li>
<li><code>Bytes</code></li>
</ul>
<h2><a class="header" href="#choice-adjective-prefix" id="choice-adjective-prefix">Choice: Adjective Prefix?</a></h2>
<p>E.g., <code>TransmuteFrom</code> or <code>IntrinsicTransmuteFrom</code>?</p>
<p>Should the root word be prefixed with another word?</p>
<p>If so, what? Some possibilities:</p>
<ul>
<li><code>Intrinsic</code></li>
<li><code>Raw</code></li>
<li><code>Is</code></li>
</ul>
<h1><a class="header" href="#should-the-trait-have-methods" id="should-the-trait-have-methods">Should the trait have methods?</a></h1>
<p>Many use-cases of <code>BikeshedIntrinsicFrom</code> involve using something like this <code>BikeshedIntrinsicFrom</code>-bounded function:</p>
<pre><code class="language-rust ignore">#[inline(always)]
unsafe fn transmute&lt;Src, Dst, Scope, const NEGLECT: Neglect&gt;(src: Src) -&gt; Dst
where
    Dst: BikeshedIntrinsicFrom&lt;Src, Scope, NEGLECT&gt;
{

    #[repr(C)]
    union Transmute&lt;Src, Dst&gt; {
        src: ManuallyDrop&lt;Src&gt;,
        dst: ManuallyDrop&lt;Dst&gt;,
    }

    ManuallyDrop::into_inner(Transmute { src: ManuallyDrop::new(src) }.dst)
}
</code></pre>
<p>Defining this function <em>could</em> be left as an exercise to the end-user. Or, <code>mem</code> could provide it. <strong>We don't need to resolve this for the initial proposal</strong>, but having an inkling of how we'd like to tackle it may affect how we name and structure the items defined by this proposal.</p>
<p>That function, as defined, cannot be added to the root of <code>mem</code>, because it would conflict with <code>mem::transmute</code>.</p>
<p>We could resolve this conflict by:</p>
<ol>
<li>using a <a href="./unresolved-trait-name.html">name</a> other than &quot;transmute&quot; for this proposal.</li>
<li>placing <code>BikeshedIntrinsicFrom</code>, <code>Neglect</code>, and this function under a new module (e.g., <code>mem::cast</code>)</li>
<li>defining an associated function on <code>BikeshedIntrinsicFrom</code>; e.g.:
<pre><code class="language-rust ignore">pub unsafe trait BikeshedIntrinsicFrom&lt;Src, Scope, const NEGLECT: Neglect&gt;
where
    Src: ?Sized
{
    unsafe fn unsafe_bikeshed_from(src: Src) -&gt; Self
    where
        Src: Sized
    {
        #[repr(C)]
        union Transmute&lt;Src, Dst&gt; {
            src: ManuallyDrop&lt;Src&gt;,
            dst: ManuallyDrop&lt;Dst&gt;,
        }

        ManuallyDrop::into_inner(Transmute { src: ManuallyDrop::new(src) }.dst)
    }
}
</code></pre>
<strong>Selecting this option might have ergonomic implications for the <a href="unresolved-trait-orientation.html">orientation</a> of our trait.</strong></li>
</ol>
<h1><a class="header" href="#trait-orientation-from-or-into" id="trait-orientation-from-or-into">Trait Orientation: <code>From</code> or <code>Into</code>?</a></h1>
<p>Should it be <code>BikeshedIntrinsicFrom</code> or <code>BikeshedIntrinsicInto</code>? What factors should be considered?</p>
<h2><a class="header" href="#from" id="from"><code>From</code></a></h2>
<pre><code class="language-rust ignore">pub unsafe trait BikeshedIntrinsicFrom&lt;Src, Scope, const NEGLECT: Neglect&gt;
where
    Src: ?Sized
{
    unsafe fn unsafe_bikeshed_from(src: Src) -&gt; Self
    where
        Src: Sized,
        Self: Sized,
    {
        #[repr(C)]
        union Transmute&lt;Src, Dst&gt; {
            src: ManuallyDrop&lt;Src&gt;,
            dst: ManuallyDrop&lt;Dst&gt;,
        }

        ManuallyDrop::into_inner(Transmute { src: ManuallyDrop::new(src) }.dst)
    }
}
</code></pre>
<h2><a class="header" href="#into" id="into"><code>Into</code></a></h2>
<pre><code class="language-rust ignore">pub unsafe trait BikeshedIntrinsicInto&lt;Dst, Scope, const NEGLECT: Neglect&gt;
where
    Dst: ?Sized
{
    unsafe fn unsafe_bikeshed_into(self) -&gt; Dst
    where
        Self: Sized,
        Dst: Sized,
    {
        #[repr(C)]
        union Transmute&lt;Src, Dst&gt; {
            src: ManuallyDrop&lt;Src&gt;,
            dst: ManuallyDrop&lt;Dst&gt;,
        }

        ManuallyDrop::into_inner(Transmute { src: ManuallyDrop::new(self) }.dst)
    }
}
</code></pre>
<h1><a class="header" href="#visibility-of-src" id="visibility-of-src">Visibility of Src?</a></h1>
<p>In the below example, is <code>downstream::as_bytes</code> sound?</p>
<pre><code class="language-rust ignored">mod upstream {
    /// Implement this to promise that your type's layout consists
    /// solely of initialized bytes with no library invariants.
    pub unsafe trait POD {}
}

mod downstream {
    use super::*;

    pub fn as_bytes&lt;'t, T&gt;(t: &amp;'t T) -&gt; &amp;'t [T]
    where
        T: upstream::POD,
    {
        use core::{slice, mem::size_of};
        
        unsafe {
            slice::from_raw_parts(t as *const T as *const u8, size_of::&lt;T&gt;())
        }
    }
}
</code></pre>
<p>The answer to this question impacts the implementation details of <code>BikeshedIntrinsicFrom</code>.</p>
<p><strong>If yes</strong>, then the <a href="introduction.html#when-is-a-transmutation-well-defined-and-safe">three aforementioned visibility conditions</a> are sufficient.</p>
<p><strong>If no</strong>, there is a fourth condition necessary for safety:</p>
<blockquote>
<p>In order to be <strong>safe</strong>, a well-defined transmutation must also not allow you to:</p>
<ol>
<li>construct instances of a hidden <code>Dst</code> type</li>
<li>mutate hidden fields of the <code>Src</code> type</li>
<li>construct hidden fields of the <code>Dst</code> type</li>
<li><em><strong>read hidden fields of the <code>Src</code> type</strong></em></li>
</ol>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
